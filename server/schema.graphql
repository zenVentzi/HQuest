scalar DateTime

type Book {
  title: String!
  created: DateTime!
  author: String!
}

type PageInfo {
  startCursor: String,
  endCursor: String,
  hasNextPage: Boolean!,  
  hasPreviousPage: Boolean!
}

interface Node {
  id: ID!
}

interface Edge {
  cursor : String!
  node: Node!
}

interface Connection {
  pageInfo: PageInfo!
  edges: [Edge!]
}

interface Notification {
  id: ID!
  type: NotificationType!
  performerId: ID!
  performerAvatarSrc: String!
  text: String!
  seen: Boolean!
  createdOn: DateTime!
}

interface News {
  type: NewsType!
  performer: User!
  createdOn: DateTime!
}

type SocialMediaLinks {
  facebookLink: String
  twitterLink: String
  instagramLink: String
  linkedInLink: String
}

type User {
  id: ID!
  me: Boolean
  email: String
  fullName: String
  intro: String
  socialMediaLinks: SocialMediaLinks
  avatarSrc: String
  following: [ID!]
  followers: [ID!]
}

enum QuestionType {
  SCALE
  TEXT
  OPTIONS
  WOULD_YOU_SINGLE
  WOULD_YOU_DOUBLE
}

# question should be made an interface
type Question implements Node {
  id: ID!
  type: QuestionType!
  possibleAnswers: [String!]
  #TODO consistency, change the type from int to string
  defaultAnswer: Int
  tags: [String!]
  question: String!
  answer: Answer
}

type QuestionEdge implements Edge {
  cursor: String!
  node: Question!
}

type QuestionConnection implements Connection {
  pageInfo: PageInfo!
  edges: [QuestionEdge!]
  totalCount: Int!
}

type Answer {
  id: ID!
  userId: ID!
  questionId: ID!
  value: String!
  comments: [Comment!]
  likes: Likes
  editions: [AnswerEdition!]
  position: Int!
}

type Likes {
  total: Int!
  likers: [Liker!]
}

type Liker {
  user: User!
  numOfLikes: Int!
}

type AnswerEdition {
  id: ID!
  date: DateTime
  before: String!
  after: String!
}

type Comment {
  id: ID!
  user: User!
  comment: String!
}

enum NewsType {
  NEW_ANSWER
  NEW_ANSWER_EDITION
  NEW_COMMENT
  NEW_LIKE
  NEW_FOLLOWER
}

type AnswerNews implements News {
  type: NewsType!
  performer: User!
  question: Question!
  createdOn: DateTime!
}

type CommentNews implements News {
  type: NewsType!
  performer: User!
  answerOwner: User!
  question: Question!
  commentId: ID!
  createdOn: DateTime!
}


type NewFollowerNews implements News {
  type: NewsType!
  performer: User!
  followedUser: User!
  createdOn: DateTime!
}

type NewLikeNews implements News {
  type: NewsType!
  performer: User!
  answerOwner: User!
  question: Question!
  createdOn: DateTime!
}

enum NotificationType {
  NEW_FOLLOWER
  NEW_COMMENT
}

type NewComment implements Notification {
  id: ID!
  type: NotificationType!
  performerId: ID!
  performerAvatarSrc: String!
  text: String!
  seen: Boolean!
  createdOn: DateTime!
  questionId: ID!
  commentId: ID!
}

type NewFollower implements Notification {
  id: ID!
  type: NotificationType!
  performerId: ID!
  performerAvatarSrc: String!
  text: String!
  seen: Boolean!
  createdOn: DateTime!
}

type LoginResult {
  authToken: String!
  userId: ID!
}

type Query {
  books: [Book!]!
  comments(answerId: ID!): [Comment!]
  notifications: [Notification]!
  book(title: String): Book
  users(match: String): [User!]!
  user(id: ID!): User
  questionsTags: [String!]!
  followers(userId: ID!): [User!]!
  following(userId: ID!): [User!]!
  newsfeed: [News!]
  questions(answered: Boolean!, userId: ID!, tags: [String], first: Int!, after: String): QuestionConnection!
  answeredQuestion(userId: ID!, questionId: ID!): Question!
}

input SocialMediaLinksInput {
  facebookLink: String!
  twitterLink: String!
  instagramLink: String!
  linkedInLink: String!
}

input EditUserInput {
  fullName: String!
  intro: String!
  socialMediaLinks: SocialMediaLinksInput!
}

type Mutation {
  addBook(title: String!, author: String!): Book!
  editUser(input: EditUserInput): User!
  notifsMarkSeen: Boolean
  commentAnswer(answerId: ID!, comment: String!): Comment!
  signUp(firstName: String!, surName: String!, email: String!, password: String!): String
  login(email: String!, name: String!): LoginResult!
  createQuestion(question: String!, type: QuestionType!, defaultAnswer: Int, possibleAnswers: [String!], tags: [String!]!): String
  questionNotApply(questionId: ID!): Question!
  editAnswer(answerId: ID!, answerValue: String!): Answer!
  addAnswer(questionId: ID!, answerValue: String!): Answer!
  removeAnswer(answerId: ID!): Answer!
  likeAnswer(answerId: ID!, numOfLikes: Int!): Answer!
  moveAnswerPosition(answerId: ID!, position: Int!): Int
  removeQuestion(questionId: ID!): Question!
  uploadAvatar(base64Img: String!): String!
  follow(userId: ID!, follow: Boolean!): Boolean
}

""" 

export const QUESTION_NOT_APPLY = gql`
  mutation questionNotApply($questionId: ID!) {
    questionNotApply(questionId: $questionId) {
      ...QuestionFields
    }
  }
  ${QuestionFields}
`;

 """

type Subscription {
  bookAdded: Book!
  newNotification(userId: ID!): Notification!
}